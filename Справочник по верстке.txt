bemep@email-host.info
morf6673

-JS
	-JavaScript – это язык, чувствительный к регистру символов

	-округление
		Math.pow(2,53) // => 9007199254740992: 2 в сте­пе­ни 53
		Math.round(.6) // => 1.0: ок­руг­ле­ние до бли­жай­ше­го це­ло­го
		Math.ceil(.6) // => 1.0: ок­руг­ле­ние вверх
		Math.floor(.6) // => 0.0: ок­руг­ле­ние вниз
		Math.abs(-5) // => 5: аб­со­лют­ное зна­че­ние
		Math.max(x,y,z) // Воз­вра­ща­ет наи­боль­ший ар­гу­мент
		Math.min(x,y,z) // Воз­вра­ща­ет наи­мень­ший ар­гу­мент
		Math.random() // Псев­до­слу­чай­ное чис­ло x, где 0 <= x < 1.0
		Math.PI // π: дли­на ок­руж­но­сти / диа­метр
		Math.E // e: Ос­но­ва­ние на­ту­раль­но­го ло­га­риф­ма
		Math.sqrt(3) // Ко­рень квад­рат­ный из 3
		Math.pow(3, 1/3) // Ко­рень ку­би­че­ский из 3
		Math.sin(0) // Три­го­но­мет­рия: име­ют­ся так­же Math.cos, Math.atan и дру­гие.
		Math.log(10) // На­ту­раль­ный ло­га­рифм 10
		Math.log(100)/Math.LN10 // Ло­га­рифм 100 по ос­но­ва­нию 10 (де­ся­тич­ный)
		Math.log(512)/Math.LN2 // Ло­га­рифм 512 по ос­но­ва­нию 2
		Math.exp(3) // Math.E в ку­бе

	-Дата
		var then = new Date(2010, 0, 1); // Пер­вый день пер­во­го ме­ся­ца 2010 го­да
		var later = new Date(2010, 0, 1, 17, 10, 30); // Та же да­та, в 17:10:30 ло­каль­но­го вре­ме­ни
		var now = new Date(); // Те­ку­щие да­та и вре­мя
		var elapsed = now - then; // Раз­ность дат: ин­тер­вал в мил­ли­се­кун­дах
		later.getFullYear() // => 2010
		later.getMonth() // => 0: счет ме­ся­цев на­чи­на­ет­ся с ну­ля
		later.getDate() // => 1: счет дней на­чи­на­ет­ся с еди­ни­цы
		later.getDay() // => 5: день не­де­ли. 0 - воскр., 5 - пятн.
		later.getHours() // => 17: 17 ча­сов ло­каль­но­го вре­ме­ни
		later.getUTCHours() // ча­сы по UTC; за­ви­сит от ча­со­во­го поя­са
		later.toString() // => "Fri Jan 01 2010 17:10:30 GMT+0300"
		later.toUTCString() // => "Fri, 01 Jan 2010 14:10:30 GMT"
		later.toLocaleDateString() // => "1 Ян­варь 2010 г."
		later.toLocaleTimeString() // => "17:10:30"
		later.toISOString() // => "2010-01-01T14:10:30.000Z"

	-Экранирование

		'You\'re right, it can\'t be a quote'

	-Объявляя переменные с глобальной областью видимости, инструкцию var можно опустить, но при объявлении локальных переменных всегда следует использовать инструкцию var
		scope = "global"; // Объ­яв­ле­ние гло­баль­ной пе­ре­мен­ной, да­же без var.
		function checkscope2() {
		 scope = "local"; // Ой! Мы из­ме­ни­ли гло­баль­ную пе­ре­мен­ную.
		 myscope = "local"; // Не­яв­но объ­яв­ля­ет­ся но­вая глоб. пе­ре­мен­ная.
		 return [scope, myscope]; // Вер­нуть два зна­че­ния.
		}

	-Определения функций могут быть вложенными. Каждая функция имеет собственную локальную область видимости, поэтому может быть несколько вложенных уровней локальных областей видимости.
		var scope = "global scope"; // Гло­баль­ная пе­ре­мен­ная
		function checkscope() {
		 var scope = "local scope"; // Ло­каль­ная пе­ре­мен­ная
		 function nested() {
		 var scope = "nested scope"; // Вло­жен­ная об­ласть ви­ди­мо­сти ло­каль­ных пе­ре­мен­ных
		 return scope; // Вер­нет зна­че­ние этой пе­ре­мен­ной scope
		 }
		 return nested();
		}
		checkscope() // => "nested scope"

	-Вместо этого в JavaScript используется такое понятие, как область видимости функции: переменные, объявленные внутри функции, 
		доступны внутри функции, где они объявлены, а также внутри всех функций, вложенных в эту функцию
		function test(o) {
		 var i = 0; // i оп­ре­де­ле­на в те­ле всей функ­ции
		 if (typeof o == "object") {
		 var j = 0; // j оп­ре­де­ле­на вез­де, не толь­ко в бло­ке
		 for(var k=0; k < 10; k++) { // k оп­ре­де­ле­на вез­де, не толь­ко в цик­ле
		 console.log(k); // вы­ве­дет чис­ла от 0 до 9
		 }
		 console.log(k); // k по-преж­не­му оп­ре­де­ле­на: вы­ве­дет 10
		 }
		 console.log(j); // j оп­ре­де­ле­на, но мо­жет быть не­ини­циа­ли­зи­ро­ва­на
		}

	-переменные оказываются видимыми внутри функции еще до того, как будут объявлены. Эта особенность JavaScript неофициально называется подъемом:
		var scope = "global";
		function f() {
		 console.log(scope); // Вы­ве­дет "undefined", а не "global"
		 var scope = "local"; // Ини­циа­ли­зи­ру­ет­ся здесь, а оп­ре­де­ле­на вез­де
		 console.log(scope); // Вы­ве­дет "local" а если убрать var scope = "local" внутри функции то выведет  global
		} //значение var глобального попадет в первый console.log только если убрать объявление переменной в функции
		эта функция "подъемя" эквивалентна функции ниже
		function f() {
		 var scope; // Объ­яв­ле­ние ло­каль­ной пе­ре­мен­ной в на­ча­ле функ­ции
		 console.log(scope); // Здесь она дос­туп­на, но име­ет зна­че­ние "undefined"
		 scope = "local"; // Здесь она ини­циа­ли­зи­ру­ет­ся и по­лу­ча­ет свое зна­че­ние
		 console.log(scope); // А здесь она име­ет ожи­дае­мое зна­че­ние
		}
		Поскольку в JavaScript не поддерживаются области видимости блоков, нужно объявлять все переменные в начале функции, а не рядом с местом, где они используются

	-удаление переменных
		var truevar = 1; // Пра­виль­но объ­яв­лен­ная гло­баль­ная пе­ре­мен­ная, не­уда­ляе­мая.
		fakevar = 2; // Соз­да­ет­ся уда­ляе­мое свой­ст­во гло­баль­но­го объ­ек­та.
		this.fakevar2 = 3; // То же са­мое.
		delete truevar // => false: пе­ре­мен­ная не бы­ла уда­ле­на
		delete fakevar // => true: пе­ре­мен­ная уда­ле­на
		delete this.fakevar2 // => true: пе­ре­мен­ная уда­ле­на

	-Глобальные переменные определены для всей программы в целом. Локальные переменные определены для всей функции, в которой они объявлены, а также для любых функций, вложенных в эту функцию
		var global = this; // Оп­ре­де­лить гло­баль­ную пе­ре­мен­ную для ссыл­ки на гло­баль­ный объ­ект
		В клиентском JavaScript роль глобального объекта для всего JavaScript-кода, содержащегося в соответствующем ему окне броузера, играет объект Window

	-Комментарии
		// Это од­но­строч­ный ком­мен­та­рий.
		/* Это то­же ком­мен­та­рий */ // а это дру­гой ком­мен­та­рий.
		/*
		* Это еще один ком­мен­та­рий.
		* Он рас­по­ла­га­ет­ся в не­сколь­ких стро­ках.
		*/

	-Типы данных в JavaScript можно разделить на две категории: простые типы и объекты.
		Любое значение в языке JavaScript, не являющееся числом, строкой, логическим значением или специальным значением null или undefined, является объектом. 

		В JavaScript определен еще один специальный тип объекта, известный как функция. Функция – это объект, с которым связан выполняемый код. Функция может
		вызываться для выполнения определенной операции и возвращать вычисленное значение.

		Функции, которые пишутся для инициализации вновь создаваемых объектов (с оператором new), называются конструкторами.

		Каждый конструктор определяет класс объектов – множество объектов, инициализируемых этим конструктором. 
		Классы можно представлять как подтипы объектного типа. 
		В дополнение к классам Array и Function в базовом языке JavaScript определены еще три полезных класса. 
		Класс Date определяет объекты, представляющие даты.
		Класс RegExp определяет объекты, представляющие регулярные выражения. 
		А класс Error определяет объекты, представляющие синтаксические ошибки и ошибки времени выполнения, которые могут возникать в программах на языке JavaScript. 
		Имеется возможность определять собственные классы объектов, объявляя соответствующие функции-конструкторы.

		JavaScript – это объектно-ориентированный язык программирования

		Переменные, объявленные внутри функции, находятся в области видимости функции и доступны только внутри этой функции

	-Объекты

		-JSON
			Сериализация объектов – это процесс преобразования объектов в строковую форму представления, которая позднее может использоваться для их восстановления.
			o = {x:1, y:{z:[false,null,""]}}; // Оп­ре­де­лить ис­пы­та­тель­ный объ­ект
			s = JSON.stringify(o); // s == '{"x":1,"y":{"z":[false,null,""]}}'
			p = JSON.parse(s); // p - глу­бо­кая ко­пия объ­ек­та o

		-toString()
			var s = { x:1, y:1 }.toString( );
			стр165

		null // Пус­той объ­ект

		-var book = { 
			заключаются в фигурные скобки.
			topic: "JavaScript", // Свойство "topic" имеет значение "JavaScript".
			fat: true // Свойство "fat" имеет значение true.
		}; // Фигурная скобка отмечает конец объекта.

		// Доступк свойствам объектов выполняется с помощью . или []:

		book.topic // => "Ja­va­Script"
		book["fat"] // => true: дру­гой спо­соб по­лу­чить зна­че­ние свойства.
		book.author = "Flanagan"; // Соз­дать но­вое свой­ст­во при­сваи­ва­ни­ем.
		book.contents = {}; // {} - пус­той объ­ект без свойств.

		Атрибут prototype содержит ссылку на другой объект, от которого наследуются свойства.


		Атрибут class содержит строку с именем класса объекта и определяет тип объекта.

		-new
			Оператор new создает и инициализирует новый объект. За этим оператором должно следовать имя функции. Функция, 
			используемая таким способом, называется конструктором и служит для инициализации вновь созданного объекта
			var o = new Object(); // Соз­дать но­вый пус­той объ­ект: то же, что и {}.
			var a = new Array(); // Соз­дать пус­той мас­сив: то же, что и [].

		-Object.create()
			Стандарт ECMAScript 5 определяет метод Object.create(), который создает новый
			объект и использует свой первый аргумент в качестве прототипа этого объекта

			Object.create() является статической функцией, а не методом, вызываемым относительно некоторого 
			конкретного объекта. Чтобы вызвать эту функцию, достаточно передать ей желаемый объект-прототип:
			var o1 = Object.create({x:1, y:2}); // o1 на­сле­ду­ет свой­ст­ва x и y.

		-delete
			delete book.author; // Те­перь объ­ект book не име­ет свой­ст­ва author.
			delete book["main title"]; // Те­перь он не име­ет свой­ст­ва "main title".

			Оператор delete удаляет только собственные свойства и не удаляет унаследованные. 
			(Чтобы удалить унаследованное свойство, необходимо удалять его в объекте-прототипе, в котором оно определено. Такая операция затронет все объекты,
			наследующие этот прототип.)

			o = {x:1}; // o име­ет соб­ст­вен­ное свой­ст­во x и на­сле­ду­ет toString
			delete o.x; // Уда­лит x и вер­нет true
			delete o.x; // Ни­че­го не сде­ла­ет (x не су­ще­ст­ву­ет) и вер­нет true
			delete o.toString; // Ни­че­го не сде­ла­ет (toString не соб­ст­вен­ное свой­ст­во) и вер­нет true
			delete 1; // Бес­смыс­лен­но, но вер­нет true

			delete Object.prototype; // Уда­ле­ние не­воз­мож­но - не­на­страи­вае­мое свой­ст­во
			var x = 1; // Объ­яв­ле­ние гло­баль­ной пе­ре­мен­ной
			delete this.x; // Это свой­ст­во нель­зя уда­лить
			function f() {} // Объ­яв­ле­ние гло­баль­ной функ­ции
			delete this.f; // Это свой­ст­во так­же нель­зя уда­лить (false везде)

		-Проверка существования свойств
			Оператор in требует, чтобы в левом операнде ему было передано имя свойства
			(в виде строки) и объект в правом операнде. Он возвращает true, если объект имеет собственное или унаследованное свойство с этим именем:

			var o = { x: 1 }
			"x" in o; // true: o име­ет соб­ст­вен­ное свой­ст­во "x"
			"y" in o; // false: o не име­ет свой­ст­ва "y"
			"toString" in o; // true: o на­сле­ду­ет свой­ст­во toString

			-hasOwnProperty()
				Метод hasOwnProperty() объекта проверяет, имеет ли объект собственное свойство
				с указанным именем. Для наследуемых свойств он возвращает false:
				var o = { x: 1 }
				o.hasOwnProperty("x"); // true: o име­ет соб­ст­вен­ное свой­ст­во x
				o.hasOwnProperty("y"); // false: не име­ет свой­ст­ва y
				o.hasOwnProperty("toString"); // false: toString - на­сле­дуе­мое свой­ст­во

				for(p in o) {
					 if (!o.hasOwnProperty(p)) continue; // Про­пус­тить унас­ле­до­ван­ные свой­ст­ва
					}
				for(p in o) {
				 if (typeof o[p] === "function") continue; // Про­пус­тить ме­то­ды
				}

	-Массивы 
		var a = []; // Соз­дать пус­той мас­сив
		a.push(1,2,3); // Ме­тод push() до­бав­ля­ет эле­мен­ты в мас­сив
		a.reverse(); // Дру­гой ме­тод: пе­ре­став­ля­ет эле­мен­ты в об­рат­ном по­ряд­ке

		//Ja­va­Script под­дер­жи­ва­ет мас­си­вы (спи­ски с чи­сло­вы­ми ин­дек­са­ми) зна­че­ний:
		var primes = [2, true, 5, ]; // Мас­сив из 4 зна­че­ний, ог­ра­ни­чи­ва­ет­ся [ и ].
		var a = primes[0] // => 2: пер­вый эле­мент (с ин­дек­сом 0) мас­си­ва.
		primes.length // => 4: ко­ли­че­ст­во эле­мен­тов в мас­си­ве.
		primes[primes.length-1] // => 7: по­след­ний эле­мент мас­си­ва.
		primes[4] = 9; // До­ба­вить но­вый эле­мент при­сваи­ва­ни­ем.
		primes[4] = 11; // Или из­ме­нить зна­че­ние имею­ще­го­ся эле­мен­та.
		var empty = []; // [] - пус­той мас­сив без эле­мен­тов.

		 Например, следующий массив содержит пять элементов, включая три элемента с неопределенными значениями: var sparseArray = [1,,,,5];

		-Мас­си­вы и объ­ек­ты мо­гут хра­нить дру­гие мас­си­вы и объ­ек­ты:
			var points = [ // Мас­сив с 2 эле­мен­та­ми.
			 {x:0, y:0}, // Ка­ж­дый эле­мент - это объ­ект.
			 {x:1, y:1}
			];
			var data = { // Объ­ект с 2 свой­ст­ва­ми
			 trial1: [[1,2], [3,4]], // Зна­че­ние ка­ж­до­го свой­ст­ва - это мас­сив.
			 trial2: [[2,3], [4,5]] // Эле­мен­та­ми мас­си­ва яв­ля­ют­ся мас­си­вы.
			};

		-length
			при присваивании свойству length неотрицательного целого числа n, меньшего, чем его текущее значение, все элементы массива с индексами,
			большими или равными значению n, удаляются из массива:
			a = [1,2,3,4,5]; // Соз­дать мас­сив с пя­тью эле­мен­та­ми.
			a.length = 3; // те­перь мас­сив a со­дер­жит эле­мен­ты [1,2,3].

		-Добавление и удаление элементов массива
			a = [] // Соз­дать пус­той мас­сив.
			a[0] = "zero"; // И до­ба­вить эле­мен­ты.
			a[1] = "one";

			-push
				a = []; // Соз­дать пус­той мас­сив
				a.push("zero") // До­ба­вить зна­че­ние в ко­нец. a = ["zero"]
				a.push("one", "two") // До­ба­вить еще два зна­че­ния. a = ["zero", "one", "two"]

			-pop 
				удаляет элеменит из конца массива массива

			shift
				удаляет элеменит из начала массива. В отличие от оператора delete сдвигает все элементы вниз на позицию ниже их текущих индексов
			
			-delete
				a = [1,2,3];
				delete a[1]; // те­перь в мас­си­ве a от­сут­ст­ву­ет эле­мент с ин­дек­сом 1
				1 in a // => false: ин­декс 1 в мас­си­ве не оп­ре­де­лен
				a.length // => 3: опе­ра­тор delete не из­ме­ня­ет свой­ст­во length мас­си­ва

			-splice многоцелевой метод изменяет исходный массив, относительно которого он был вызван
				var a = [1,2,3,4,5,6,7,8];
				a.splice(4); // Вер­нет [5,6,7,8]; a = [1,2,3,4]
				a.splice(1,2); // Вер­нет [2,3]; a = [1,4]
				a.splice(1,1); // Вер­нет [4]; a = [1]
				Первые два аргумента метода splice() определяют элементы массива, подлежащие удалению. За этими аргументами может следовать любое количество допол-
				7.8. Методы класса Array 175
				нительных аргументов, определяющих элементы, которые будут вставлены в массив, начиная с позиции, указанной в первом аргументе. Например:
				var a = [1,2,3,4,5];
				a.splice(2,0,'a','b'); // Вер­нет []; a = [1,2,'a','b',3,4,5]
				a.splice(2,2,[1,2],3); // Вер­нет ['a','b']; a = [1,2,[1,2],3,3,4,5]
				Обратите внимание, что, в отличие от concat(), метод splice() вставляет массивы
				целиком, а не их элементы.

		-Обход элементов массива
			Во вложенных циклах и в других контекстах, когда скорость работы имеет критическое значение, иногда можно 
			увидеть такой оптимизированный способ выполнения итераций по массиву, когда длина массива определяется только один раз, а не в каждой итерации:
			
			-проверка на несуществующие элементы
				for(var i = 0, len = keys.length; i < len; i++) {
				// те­ло цик­ла ос­та­лось без из­ме­не­ний
				}
			-Если необходимо пропустить только значение undefined и несуществующие элементы, проверку можно записать так:
				for(var i = 0; i < a.length; i++) {
				 if (!a[i]) continue; // Про­пус­тить null, undefined и не­су­ществ. эле­мен­ты
				 // те­ло цик­ла
				}

			-forEach обход через 
				https://www.youtube.com/watch?v=cGA3N5coak4

				var data = [1,2,3,4,5]; // Этот мас­сив тре­бу­ет­ся обой­ти
				var sumOfSquares = 0; // Тре­бу­ет­ся вы­чис­лить сум­му квад­ра­тов эле­мен­тов
				data.forEach(function(x) { // Пе­ре­дать ка­ж­дый эле­мент этой функ­ции
				 sumOfSquares += x*x; // при­ба­вить квад­рат к сум­ме
				 });
				sumOfSquares // =>55 : 1+4+9+16+25

				При вызове этой функции метод forEach() будет
				передавать ей три аргумента: значение элемента массива, индекс элемента и сам 
				7.9. Методы класса Array, определяемые стандартом ECMAScript 5 177
				массив. Если вас интересует только значение элемента, можно написать функцию с одним параметром – дополнительные аргументы будут игнорироваться:
				var data = [1,2,3,4,5]; // Мас­сив, эле­мен­ты ко­то­ро­го бу­дут сум­ми­ро­вать­ся
				// Най­ти сум­му эле­мен­тов мас­си­ва
				var sum = 0; // На­чаль­ное зна­че­ние сум­мы 0
				data.forEach(function(value) { sum += value; }); // При­ба­вить зна­че­ние к sum
				sum // => 15
				// Уве­ли­чить все эле­мен­ты мас­си­ва на 1
				data.forEach(function(v, i, a) { a[i] = v + 1; });
				data // => [2,3,4,5,6]

		- методы

			-forEach()

			-join()
				Метод Array.join() преобразует все элементы массива в строки, объединяет их и возвращает получившуюся строку
				var a = [1, 2, 3]; // Соз­дать но­вый мас­сив с ука­зан­ны­ми тре­мя эле­мен­та­ми
				a.join(); // => "1,2,3"

			-reverse() Перестановка выполняется непосредственно в исходном массиве
				var a = [1,2,3];
				a.reverse().join(); // => "3,2,1": те­перь a = [3,2,1]

			-sort сортирует массив
				var a = new Array("banana", "cherry", "apple");
				a.sort();
				var s = a.join("; ") //"apple; banana; cherry"
				Неопределенные элементы переносятся в конец массива

			- concat()
				var a = [1,2,3];
				a.concat(4, 5) // Вер­нет [1,2,3,4,5]
				a.concat([4,5]); // Вер­нет [1,2,3,4,5]
				a.concat([4,5],[6,7]) // Вер­нет [1,2,3,4,5,6,7]
				a.concat(4, [5,[6,7]]) // Вер­нет [1,2,3,4,5,[6,7]]

			-Метод slice()
				Два аргумента метода определяют начало и конец возвращаемого фрагмента.
				Возвращаемый массив содержит элемент, номер которого указан в первом аргументе, плюс все последующие элементы, вплоть до (но не включая) элемента, номер которого указан во втором аргументе. Если указан только один аргумент,
				возвращаемый массив содержит все элементы от начальной позиции до конца
				массива. Если какой-либо из аргументов имеет отрицательное значение, он определяет номер элемента относительно конца массива. Так, аргументу –1 соответствует последний элемент массива, а аргументу –3 – третий элемент массива с конца. Вот несколько примеров:
				var a = [1,2,3,4,5];
				a.slice(0,3); // Вер­нет [1,2,3]
				a.slice(3); // Вер­нет [4,5]
				a.slice(1,-1); // Вер­нет [2,3,4]
				a.slice(-3,-2); // Вер­нет [3]

			-map() 
				Метод map() передает указанной функции каждый элемент массива, относительно которого он вызван, и возвращает массив значений, возвращаемых этой функцией. Например:
				a = [1, 2, 3];
				b = a.map(function(x) { return x*x; }); // b = [1, 4, 9]
				возвращает новый массив: он не изменяет исходный массив

			-reduce() и reduceRight() разобраться как работают

			- indexOf() и lastIndexOf()
				Методы indexOf() и lastIndexOf() отыскивают в массиве элемент с указанным значением и возвращают индекс первого найденного элемента или –1, если элемент
				с таким значением отсутствует. Метод indexOf() выполняет поиск от начала массива к концу, а метод lastIndexOf() – от конца к началу.
				a = [0,1,2,1,0];
				a.indexOf(1) // => 1: a[1] = 1
				a.lastIndexOf(1) // => 3: a[3] = 1
				a.indexOf(3) // => -1: нет эле­мен­та со зна­че­ни­ем 3

	-Преобразования и равенство

		-строки
			"3" + "2" // => "32": + скла­ды­ва­ет чис­ла, объ­еди­ня­ет стро­ки

			var name = 1;
			var greeting = 'Доб­ро по­жа­ло­вать на мою до­маш­нюю стра­ни­цу ' + name + '  ' ; 
			console.log(greeting); //"Доб­ро по­жа­ло­вать на мою до­маш­нюю стра­ни­цу 1  "

			s.length
			s.split(", ") // => ["hello", "world"] раз­би­ва­ет на под­стро­ки
			s.replace("h", "H") // => "Hello, world": за­ме­ща­ет все вхо­ж­де­ния под­стро­ки
			s.toUpperCase() // => "HELLO, WORLD"

		-выражения
			count++; // Уве­ли­че­ние зна­че­ния пе­ре­мен­ной на 1
			count += 2; // До­ба­вить 2: то же, что count = count + 2;
			total = total + sales_tax

		-null == undefined //true
			Чтобы отличать их в программе, можно использовать оператор идентичности ===.) Оба они являются ложными значениями – в логическом
			контексте они интерпретируются как значение false. Ни null, ни undefined не имеют каких-либо свойств или методов

		-Преобразование типов 
			10 + " objects" // => "10 objects". Чис­ло 10 пре­об­ра­зу­ет­ся в стро­ку
			"7" * "4" // => 28: обе стро­ки пре­об­ра­зу­ют­ся в чис­ла
			var n = 1 - "x"; // => NaN: стро­ка "x" не мо­жет быть пре­об­ра­зо­ва­на в чис­ло

		null == undefined // Эти два зна­че­ния счи­та­ют­ся рав­ны­ми.
		"0" == 0 // Пе­ред срав­не­ни­ем стро­ка пре­об­ра­зу­ет­ся в чис­ло.
		0 == false // Пе­ред срав­не­ни­ем ло­гич. зна­че­ние пре­об­ра­зу­ет­ся в чис­ло.
		"0" == false // Пе­ред срав­не­ни­ем оба опе­ран­да пре­об­ра­зу­ют­ся в чис­ла.
		Операторы и инструкции JavaScript ожидают получить значения определенных типов и выполняют преобразования в эти типы
		Number("3") // => 3
		String(false) // => "false" или мож­но ис­поль­зо­вать false.toString()
		Boolean([]) // => true
		Object(3) // => new Number(3)
		var n = 123456.789;
		n.toFixed(0); // "123457"
		n.toFixed(2); // "123456.79"
		n.toFixed(5); // "123456.78900"
		n.toExponential(1); // "1.2e+5"
		n.toExponential(3); // "1.235e+5"
		Функция parseInt() анализирует только целые числа, тогда как функция parseFloat() позволяет анализировать строки, представляющие и целые, и вещественные числа
		parseInt("3 blind mice") // => 3
		parseFloat(" 3.14 meters") // => 3.14
		parseInt("-12.34") // => -12
		 Пустые массивы преобразуются в пустую строку. А пустая строка преобразуется в число 0. Массив с единственным элементом преобразуется в ту же строку, что и единственный элемент массива. Если массив содержит единственное число, это число
		преобразуется в строку, а затем опять в число.

		Оператор -, например, преобразует свои операнды в числа. Следующий фрагмент демонстрирует поведение операторов +, -, ==
		и > при работе с объектами Date:
		var now = new Date(); // Соз­дать объ­ект Date
		typeof (now + 1) // => "стро­ка": + пре­об­ра­зу­ет да­ту в стро­ку
		typeof (now - 1) // => "чис­ло": - вы­пол­нит пре­об­ра­зо­ва­ние объ­ек­та в чис­ло
		now == now.toString() // => true: не­яв­ное и яв­ное пре­об­ра­зо­ва­ние в стро­ку
		now > (now -1) // => true: > пре­об­ра­зу­ет объ­ект Date в чис­ло

	-функции 

		-Отличие функции со скобками от функции без скобок записанную в переменную заключается в том что со скобками функция выполнится сразу а без скобок, посто запишется в переменную и вызовется по ссылке позже

		-Внутри тела функции локальная переменная имеет преимущество перед глобальной переменной с тем же именем.

		-инструкции объявления функций «поднимаются» в начало сценария или вмещающей их функции, благодаря чему 
		объявленные таким способом функции могут вызываться в программном коде выше объявления

		function plus1(x) { // Оп­ре­де­лить функ­цию с име­нем "plus1" и с па­ра­мет­ром "x"
		 return x+1; // Вер­нуть зна­че­ние на 1 боль­ше по­лу­чен­но­го
		} // Функ­ции за­клю­ча­ют­ся в фи­гур­ные скоб­ки
		plus1(y) // => 4: y име­ет зна­че­ние 3, по­это­му этот вы­зов вер­нет 3+1
		var square = function(x) { // Функ­ции мож­но при­сваи­вать пе­ре­мен­ным
		 return x*x; // Вы­чис­лить зна­че­ние функ­ции
		}; // Точ­ка с за­пя­той от­ме­ча­ет ко­нец при­сваи­ва­ния.
		square(plus1(y)) // => 16: вы­зов двух функ­ций в од­ном вы­ра­же­нии

		// Оп­ре­де­ле­ние функ­ции-кон­ст­рук­то­ра для ини­циа­ли­за­ции но­во­го объ­ек­та Point
			function Point(x,y) { // По со­гла­ше­нию имя кон­ст­рук­то­ров на­чи­на­ет­ся с за­глав­но­го сим­во­ла
			 this.x = x; // this - ссыл­ка на ини­циа­ли­зи­руе­мый объ­ект
			1.2. Клиентский JavaScript 29
			 this.y = y; // Со­хра­нить ар­гу­мен­ты в свой­ст­вах объ­ек­та
			} // Ни­че­го воз­вра­щать не тре­бу­ет­ся
		// Что­бы соз­дать но­вый эк­зем­п­ляр, не­об­хо­ди­мо вы­звать функ­цию-кон­ст­рук­тор
		// с клю­че­вым сло­вом "new"
			var p = new Point(1, 1); // Точ­ка на плос­ко­сти с ко­ор­ди­на­та­ми (1,1)

		-toggle
			var itemOne = document.querySelector('.item');
			function() {
				this.classList.toggle('item-active');
			}

		-рекурсивная функция
			function factorial(x) {
			 if (x <= 1) return 1;
			 return x * factorial(x-1);
			}

		-вложенные функции
			function hypotenuse(a, b) {
				function square(x) { return x*x; }
				return Math.sqrt(square(a) + square(b));
			}

		-вызов функции
			printprops({x:1});

			var a = $(".header").map(function() { return this.id }).get().sort();
			// Оты­скать все за­го­лов­ки, ото­бра­зить их в зна­че­ния ат­ри­бу­тов id,
			// пре­об­ра­зо­вать в мас­сив и от­сор­ти­ро­вать

		-Функции как данные
			function square(x) { return x*x; }
			Функция может быть присвоена другой переменной, и при этом работать так же, как и раньше:
			var s = square; // Те­перь s ссы­ла­ет­ся на ту же функ­цию, что и square
			square(4); // => 16
			s(4); // => 16

			var o = {square: function(x) { return x*x; }}; // Ли­те­рал объ­ек­та
			var y = o.square(16); // y = 256

		-call -apply -bind 
			связка функции и данных через ссылку bind для последующего вызова и выполнения через 
			https://www.youtube.com/watch?v=OaR9Go75hOY

		-callback
			функция обротного вызова вызовется тогда, когда закончится выполнение основной функции
			https://www.youtube.com/watch?v=LM0tW2MZJZ4 1.18.00

		-e -координаты
			https://www.youtube.com/watch?v=LM0tW2MZJZ4 47.00

		-random
			https://www.youtube.com/watch?v=LM0tW2MZJZ4 1.07.00

		-замыкания
			https://www.youtube.com/watch?v=LM0tW2MZJZ4
			Но если функция определяет вложенную функцию и возвращает ее или сохраняет в свойстве какого-либо объекта, 
			то образуется внешняя ссылка на вложенную функцию. Такой объект вложенной функции не будет утилизирован сборщиком мусора, и точно так же не
			будет утилизирован объект с локальными переменными, на который она ссылается.
			Вложенная функция видит все переменные внешней функции

			var scope = "global scope"; // Гло­баль­ная пе­ре­мен­ная
			function checkscope() {
			 var scope = "local scope"; // Ло­каль­ная пе­ре­мен­ная
			 function f() { return scope; } // Вер­нет зна­че­ние ло­каль­ной пе­ре­мен­ной scope
			 return f;
			}
			checkscope()() // Ка­кое зна­че­ние вер­нет этот вы­зов?
			console.log(scope); //global scope
			console.log(checkscope()()); //local scope
			 Вложенная функция f() была определена в цепочке видимости, где переменная scope связана со значением «local scope». Эта
			связь остается действовать и при выполнении функции f, независимо от того, откуда был произведен ее вызов. 
			Поэтому последняя строка в примере выше вернет «local scope», а не «global scope»

		-length
			возвращает количество аргументов, которое функция ожидает получить, – число объявленных параметров.
			// Эта функ­ция ис­поль­зу­ет arguments.callee, по­это­му она
			// не бу­дет ра­бо­тать в стро­гом ре­жи­ме.
			function check(args) {
			 var actual = args.length; // Фак­ти­че­ское чис­ло ар­гу­мен­тов
			 var expected = args.callee.length; // Ожи­дае­мое чис­ло ар­гу­мен­тов
			 if (actual !== expected) // Ес­ли не сов­па­да­ют, ге­не­ри­ру­ет­ся ис­клю­че­ние
			 throw new Error("ожи­да­ет­ся: " + expected + "; по­лу­че­но " + actual);
			}
			function f(x, y, z) {
			 // Про­ве­рить чис­ло ожи­дае­мых и фак­ти­че­ски пе­ре­дан­ных ар­гу­мен­тов.
			 check(arguments);
			 // Те­перь вы­пол­нить ос­тав­шую­ся часть функ­ции как обыч­но
			 return x + y + z;
			}

	-методы
		Все выражения вызова включают пару круглых скобок и выражение перед открывающей круглой скобкой. Если это выражение является выражением обращения к свойству, такой вызов называется вызовом метода. При вызове метода
		объект или массив, к свойству которого производится обращение, становится значением параметра this, доступного в теле функции во время его выполнения

	-создание объекта
		Выражение создания объекта создает новый объект и вызывает функцию (называемую конструктором) для инициализации свойств этого объекта new Point(2,3)

	-идентичность ===
		Оператор идентичности === вычисляет значения своих операндов, а затем сравнивает два значения, без преобразования типов, руководствуется следующими правилами:
		• Если два значения имеют различные типы, они не идентичны.
		• Если оба операнда являются значением null или undefined, они идентичны.
		• Если оба операнда являются логическим значением true или оба являются логическим значением false, они идентичны.
		• Если одно или оба значения являются значением NaN, они не идентичны. Значение NaN никогда не бывает идентичным никакому значению, даже самому
		себе! Чтобы проверить, является ли значение x значением NaN, следует использовать выражение x !== x. Значение NaN – единственное, для которого такая
		проверка вернет true.
		• Если оба значения являются числами с одним и тем же значением, они идентичны. Если один операнд имеет значение 0, а другой –0, они также идентичны.
		• Если оба значения являются строками и содержат одни и те же 16-битные значения (подробности во врезке в разделе 3.2) в одинаковых позициях, они идентичны. Если строки отличаются длиной или содержимым, они не идентичны.
		Две строки могут иметь один и тот же смысл и одинаково выглядеть на экране, но содержать отличающиеся последовательности 16-битных значений. Интерпретатор JavaScript не выполняет нормализацию символов Юникода, поэтому подобные пары строк не считаются операторами === и == ни равными, ни
		идентичными. Другой способ сравнения строк обсуждается в части III книги,
		в описании метода String.localeCompare().
		• Если оба значения ссылаются на один и тот же объект, массив или функцию, то
		они идентичны. Если они ссылаются на различные объекты (массивы или функции), они не идентичны, даже если оба объекта имеют идентичные свойства.
		Оператор равенства == похож на оператор идентичности, но он использует менее
		строгие правила. Если значения операндов имеют разные типы, он выполняет
		преобразование типов и пытается выполнить сравнение:
		• Если два значения имеют одинаковый тип, они проверяются на идентичность,
		как было описано выше. Если значения идентичны, они равны; если они не
		идентичны, они не равны.
		• Если два значения не относятся к одному и тому же типу, оператор == все же
		может счесть их равными. При этом используются следующие правила и преобразования типов:
		• Если одно значение null, а другое – undefined, то они равны.
		• Если одно значение является числом, а другое – строкой, то строка преобразуется в число и выполняется сравнение с преобразованным значением.
		• Если какое-либо значение равно true, оно преобразуется в 1 и сравнение
		выполняется снова. Если какое-либо значение равно false, оно преобразуется в 0 и сравнение выполняется снова.
		• Если одно из значений является объектом, а другое – числом или строкой,
		объект преобразуется в простой тип (как описывалось в разделе 3.8.3) и сравнение выполняется снова. Объект преобразуется в значение простого типа
		либо с помощью своего метода toString(), либо с помощью своего метода
		valueOf(). Встроенные классы базового языка JavaScript сначала пытаются
		выполнить преобразование valueOf(), а затем toString(), кроме класса Date,
		который всегда выполняет преобразование toString(). Объекты, не являющиеся частью базового JavaScript, могут преобразовывать себя в значения
		простых типов способом, определенным их реализацией.
		• Любые другие комбинации значений не являются равными.

	-Оператор in
		Оператор in требует, чтобы левый операнд был строкой или мог быть преобразован в строку. Правым операндом должен быть объект.
		var point = { x:1, y:1 }; // Оп­ре­де­лить объ­ект
		"x" in point // => true: объ­ект име­ет свой­ст­во с име­нем "x"
		"z" in point // => false: объ­ект не име­ет свой­ст­ва с име­нем "z".
		"toString" in point // => true: объ­ект на­сле­ду­ет ме­тод toString
		var data = [7,8,9]; // Мас­сив с эле­мен­та­ми 0, 1 и 2
		"0" in data // => true: мас­сив со­дер­жит эле­мент "0"
		1 in data // => true: чис­ла пре­об­ра­зу­ют­ся в стро­ки
		3 in data // => false: нет эле­мен­та 3

	-Условный оператор тернарный
		x > 0 ? x : -x // Аб­со­лют­ное зна­че­ние x

		-switch можно делать через break а можно попробовать через return
			function convert(x) {
				 switch(typeof x) {
				 case 'number': // Пре­об­ра­зо­вать чис­ло в ше­ст­на­дца­те­рич­ное це­лое
				 return x.toString(16);
				 case 'string': // Вер­нуть стро­ку, за­клю­чен­ную в ка­выч­ки
				 return '"' + x + '"';
				 default: // Лю­бой дру­гой тип пре­об­ра­зу­ет­ся обыч­ным спо­со­бом
				 return x.toString()
				 }
				}

	-Циклы
		-while
			var count = 0;
			while (count < 10) {
			 console.log(count);
			 count++;
			}
			Как видите, в начале переменной count присваивается значение 0, а затем ее значение увеличивается каждый раз, когда выполняется тело цикла. После того как
			цикл будет выполнен 10 раз, выражение вернет false (т. е. переменная count уже
			не меньше 10), инструкция while завершится и интерпретатор перейдет к следующей инструкции в программе.

		-do-while
			Цикл doO/while во многом похож на цикл while, за исключением того, что выражение цикла проверяется в конце, а не в начале. Это значит, что тело цикла всегда
			выполняется как минимум один раз. Эта инструкция имеет следующий синтаксис:
			do
			 ин­ст­рук­ция
			while (вы­ра­же­ние);

		-For
			for(ини­циа­ли­за­ция; про­вер­ка; ин­кре­мент)
 				ин­ст­рук­ция
 			var i, j
			for(i = 0, j = 10; i < 10; i++, j--)
			sum += i * j;
			Любое из трех выражений цикла for может быть опущено, но две точки с запятой являются обязательными. Если опустить выражение про­вер­ки, цикл будет повторяться вечно

		-FOR INPUT
			Для обхода элементов массива естественно использовать обычный цикл for:
			for(var i = 0; i < a.length; i++) // При­сваи­вать ин­дек­сы в мас­си­ве пе­ре­мен­ной i
			 console.log(a[i]); // Вы­вес­ти зна­че­ние ка­ж­до­го эле­мен­та мас­си­ва
			Инструкция for/in так же естественно позволяет выполнить обход свойств объекта.
			for(var p in o) // При­сваи­вать име­на свойств объ­ек­та o пе­ре­мен­ной p
			 console.log(o[p]); // Вы­вес­ти зна­че­ние ка­ж­до­го свой­ст­ва

	-Переходы
		-break;  заставляет интерпретатор перейти в конец цикла или другой инструкции
		-continue;  заставляет интерпретатор пропустить оставшуюся часть тела цикла, перейти обратно в начало цикла и приступить к выполнению новой итерации
		-return; заставляет интерпретатор перейти из вызванной функции обратно в точку ее вызова и вернуть значение вызова
			Если функция не имеет инструкции return, при ее вызове интерпретатор будет
			выполнять инструкции в теле функции одну за другой, пока не достигнет конца
			функции, и затем вернет управление вызвавшей ее программе. В этом случае выражение вызова вернет значение undefined. Инструкция return часто является последней инструкцией в функции, но это совершенно необязательно: функция вернет управление вызывающей программе, как только будет достигнута инструкция return, даже если за ней следуют другие инструкции в теле функции.

		try/catch/finally
			try {
			 // Обыч­но этот код без сбо­ев ра­бо­та­ет от на­ча­ла до кон­ца.
			 // Но в ка­кой-то мо­мент в нем мо­жет быть сге­не­ри­ро­ва­но ис­клю­че­ние
			 // ли­бо не­по­сред­ст­вен­но с по­мо­щью ин­ст­рук­ции throw, ли­бо кос­вен­но -
			 // вы­зо­вом ме­то­да, ге­не­ри­рую­ще­го ис­клю­че­ние.
			}
			catch (e) {
			 // Ин­ст­рук­ции в этом бло­ке вы­пол­ня­ют­ся то­гда и толь­ко то­гда, ко­гда в бло­ке try
			 // воз­ни­ка­ет ис­клю­че­ние. Эти ин­ст­рук­ции мо­гут ис­поль­зо­вать ло­каль­ную пе­ре­мен­ную e,
			 // ссы­лаю­щую­ся на объ­ект Error или на дру­гое зна­че­ние, ука­зан­ное в ин­ст­рук­ции throw.
			 // Этот блок мо­жет ли­бо не­ко­то­рым об­ра­зом об­ра­бо­тать ис­клю­че­ние, ли­бо
			 // про­иг­но­ри­ро­вать его, де­лая что-то дру­гое, ли­бо за­но­во сге­не­ри­ро­вать
			 // ис­клю­че­ние с по­мо­щью ин­ст­рук­ции throw.
			}
			finally {
			 // Этот блок со­дер­жит ин­ст­рук­ции, ко­то­рые вы­пол­ня­ют­ся все­гда, не­за­ви­си­мо от то­го,
			 // что про­изош­ло в бло­ке try. Они вы­пол­ня­ют­ся, ес­ли блок try за­вер­шил­ся:
			}

		- debugger

	-классы

		-construсtor Конструктор – это функция, предназначенная для инициализации вновь созданных объектов
			class User {
				public name: string; //Данное поле Доступно как у экземпляров класса, так и у наследников класса, так и в самом классе

				private isTeacher: boolean; //Будет доступно только внутри класса

				protected age: number = 30; //Наследникам класса доступно

				constructor(name: string, job: string) { //сюда передаётся имя
					this.name = name; //обращаемся к этому полю и задаём ему значение name
					this.job = job;
				}

				public getAge (): number { // метод который возвращает
					return this.age;
				}
			}
			console.log(user.getAge()) //30 //если метод будет private то вызвать не сможем
			//Создаём экземпляр User
			const user = new User('WFM', 'FrontEnd'); //и указываем в конструкторе имя WFM

			-пример без конструктора
				function Animal(name) {
				  this.speed = 0;
				  this.name = name;

				  this.run = function(speed) {
				    this.speed += speed;
				    alert( this.name + ' бежит, скорость ' + this.speed );
				  };

				  this.stop = function() {
				    this.speed = 0;
				    alert( this.name + ' стоит' );
				  };
				};

				var animal = new Animal('Зверь');

				alert( animal.speed ); // 0, начальная скорость
				animal.run(3); // Зверь бежит, скорость 3
				animal.run(10); // Зверь бежит, скорость 13
				animal.stop(); // Зверь стоит

		-проверка на принадлежность к классу
			Слева от оператора должен находиться объект, для которого выполняется проверка принадлежности к классу,
			а справа – имя функции-конструктора, представляющей класс. Выражение o instan­ceof c возвращает true, если объект o наследует c.prototype

		-прототип (недостатки При создании методов через прототип, мы теряем возможность использовать локальные переменные как приватные свойства, у них больше нет общей области видимости с конструктором.)

			// конструктор
			function Animal(name) {
			  this.name = name;
			  this.speed = 0;
			}

			// методы в прототипе
			Animal.prototype.run = function(speed) {
			  this.speed += speed;
			  alert( this.name + ' бежит, скорость ' + this.speed );
			};

			Animal.prototype.stop = function() {
			  this.speed = 0;
			  alert( this.name + ' стоит' );
			};

			var animal = new Animal('Зверь');

			alert( animal.speed ); // 0, свойство взято из прототипа
			animal.run(5); // Зверь бежит, скорость 5
			animal.run(5); // Зверь бежит, скорость 10
			animal.stop(); // Зверь стоит

			Таким образом, прототипный стиль – быстрее и экономнее, но немного менее удобен.
			К примеру, есть у нас приватное свойство name и метод sayHi в функциональном стиле ООП:

			function Animal(name) {
			  this.sayHi = function() {
			    alert( name );
			  };
			}

			var animal = new Animal("Зверь");
			animal.sayHi(); // Зверь

			При задании методов в прототипе мы не сможем её так оставить, ведь методы находятся вне конструктора, у них нет общей области видимости, поэтому приходится записывать name в сам объект, обозначив его как защищённое:

			function Animal(name) {
			  this._name = name;
			}

			Animal.prototype.sayHi = function() {
			  alert( this._name );
			}

			var animal = new Animal("Зверь");
			animal.sayHi(); // Зверь

		-isPrototypeOf()
			Если необходимо проверить, входит ли некоторый определенный прототип в цепочку прототипов объекта без использования функции-конструктора, как промежуточного звена, можно воспользоваться методом

-Наработки верстки

	-CSS порядок свойств элементов

		.element {
			position: absolute;
				top: 0;
				left: 0;
			display: flex;
				flex-direction: column;
				flex: 0 0 50%;
				flex-wrap: wrap;
				justify-content: center;
				align-items: center;
			width: 100%;
				max-width: 100%;
			height: 100%
				max-height: 100%;
			overflow-y: auto;
			margin: 0 auto;
			padding: 0 auto;
			border: 1px solid $border-color;
			text-transform: uppercase;
			font: 400 1rem/1.2rem $font-main;

		}

	-paralax
		https://www.youtube.com/watch?v=NBMYHNwVUcc 1.17.00
	
	-чтобы изображение фоновое через background url не обрезалось ему надо задать contain
		https://www.youtube.com/watch?v=NBMYHNwVUcc 1.06.00
		w20% l20% t20% h20%

	-z-index может не работать если нет posr

	-заменять jcsb на mlauto для правого блока и mrauto для левого

	//картинка в ссылке
		a {
			w27
			h27
			lh27
			bgc000
			br50
		}

	//обертка для аватарки img
		div.avatar-img {
		br50
		w50
		h50
		df
		aic
		jcc
		}

	//без бутстрапа container
		делать ширину в % 87% для лендосов с паралаксом

	//фотошоп
		файл-генерировать набор изображений

		https://www.youtube.com/watch?v=ZY6DaPHYO34 2.10

	//lorem
		lorem4
		lorem*2

	//main
		.main {
			  min-height: calc(100vh - 15.25rem);
			  padding-top: 4rem;
			  @media screen and (min-width: 534px) {
			    min-height: calc(100vh - 5rem);
			  }
			}

	//контайнер без bootstrap
		.container {
		  display: block;
		  width: 100%;
		  margin-left: auto;
		  margin-right: auto;
		  padding-left: 15px;
		  padding-right: 15px;

		  @media screen and (max-width: 359px) { //mobile vertical 320
		  }
		  @media screen and (max-width: 533px) and (min-width: 360px) { //mobile vertical 360, 375
		  }
		  @media screen and (min-width: 534px) { //mobile horizontal 640, 667, 568, 534, 570
		  }
		  @media screen and (min-width: 768px) { //tablet vertical 768
		  }
		  @media screen and (min-width: 1024px) { //tablet horizontal 1024
		  }
		  @media screen and (max-width: 1279px) and (min-width: 1024px) {
		  }
		  @media screen and (min-width: 1280px) { //desktop 1366, 1360, 1280
		    max-width: calc(1280px - 140px);
		  }
		  @media screen and (min-width: 1440px) { //desktop 1600, 1440, 1536
		    max-width: calc(1440px - 140px);
		  }
		  @media screen and (min-width: 1680px) { //desktop 1680
		    max-width: calc(1680px - 140px);
		  }
		  @media screen and (min-width: 1920px) { //desktop 1920, 2560
		    max-width: calc(1920px - 140px);
		  }
		}

    //шрифт
        font: 300 italic 1.25rem/1.5rem $font-main;

    //пример mobile first
        .header {//здесь стили для мобилы
          min-height: 5rem;
          position: fixed;
          background-size: 100%;
          background: #f1f1f1 url('../img/house.jpg') no-repeat top right;

          @include mq($from: xsmin) {//здесь для десктопа min 534
            background: red;
            //background: #f1f1f1 url('../img/house.jpg') no-repeat center top;
          }
        }

    //паддинг в нопках
        .button {
          padding: 2rem;
          border-right: 1px solid rgba(#555555, 0.1);
        }

    //модалка
       .mfp-close {
         top: 1.375rem;
         right: 2rem;
         display: block;
         width: 1.125rem;
         height: 1.125rem;
         background: url(../img/theme/icons/close_default.svg) no-repeat center;
         background-size: .875rem;
         font-size: 0;
         opacity: 1;
       }

    //курсив шрифт
        @font-face {
          font-family: 'Montserrat';
          src: local('Montserrat'), url('../fonts/Montserrat/montserrat.woff2') format('woff2'), url('../fonts/Montserrat/montserrat.woff') format('woff'), url('../fonts/Montserrat/montserrat.ttf') format('truetype');
          font-weight: 400;
          font-style: italic;
        }

-Ошибки допущенные при верстке проекта
	1) не был до конца донастроен галп - донастроил
	2) Забыл систематизацию подготовки макета
		а)Подключаем шрифты
		б)Скачиваем картинки
		в)Смотрим размер контейнера
	3)Решил подключать шрифт не из макета и долго его искал
	4)Неправильные свойства выбивают галп
	5)Не понятно как истинно брать размеры с блоков которые содержат текст

-верскта без gulp на vc code
	-https://www.youtube.com/watch?v=mC8JW_aG2EM

	-создаем на гитхабе репозиторий через сайт гитхаба и создаем там ридми

	-клонируем через ssh купируем с сайта адрес ssh

	-создаем проект в vc папаку проекта и в ней пишем git clone адрес ssh

	-создем index.html страницу и подключаем стили

	-создаем папку sass и js (4.40 установить плагин live sass compiler sass в css там зайти в setting json)

	-нажимаем внизу кнопку watch sass в vc code

	-подготовка к комиту git add . (как сейв в игре)
		потом пишем git comit -m "сздана базовая разметка"    - это коммент в кавычках нажимаем enter
		потом отправляем на репозиторий git push

	-устанавливае плагин live server (релодит страницу) - открыть html страницу в vc code и ПКМ контекстном меню выбрать open with live server

	-header.header>.navbar+.hero|c - преобразуется в разметку с комментами закрывающегося div-a
	в sass файлах не забыть про подчеркивания и импорты

	-autoprefixer поставить для префиксов

	-подключаем normilize css

	-кликнуть на пустое место в avacode чтобы увидеть какие шрифты подключены к сайту (webfonts.pro)

	-шапка header min-height и возможно pos fixed left 0 top 0 width 100% bacground #fff

	-border-right: 1px solid rgba(#555555, 0.1) -opacity

	-span делать блочным для отступов

	-гамбургер рисовать спанами для того чтобы можно было применять анимацию

	-разницу между отступами вниз от текста используем lh а остальное на глаз доганяем mb

	-отступы внутри кнопки используем padding: 22px 22px;

	-фоновый цвет и картинка блока : background: #f1f1f1 url('../img/house.jpg') no-repeat center top (по грризонтали) 80px; но лучше сделать mt80px самому блоку с картинкой

	-фоновый размер background-size: contain
		а в media 575px
			background-size: 100%
			background-position: top right
			//background-position: top 80px right

	-padding блока с тектом в блоке с картинкой брать так: сверху отступ брать от верхнего элемента вверх (блок с тектом) и от самого нижнего элемента - вниз (кнопка)

	-nav.menu__nav>a.menu__link*7[href=#]

	-BEM .b1>.b2_m1>.-e1+.--e2_m2 эквивалентно
		<div class="b1">
		    <div class="b2 b2_m1">
		        <div class="b2__e1"></div>
		        <div class="b1__e2 b1__e2_m2"></div>
		    </div>
		</div>

	-меню в строку сайта 1.05.15
		.menu {
			posf
			zi0
			top80px (прямо под шапкой получается)
			w100%
			l0
			o0 (для макбуков, так у них можно оттягивать экран)
			transform: translateY(-100%); (заезжает под шапку)
			transform: translateY(0%); (выезжает из под шапки)
		}

-Закрыть вопросы

	-как кастомизировать селекты в 2018 году

	-Полифилы

	-GITflow фронт

	-сверстать что то

-Гриды

-микроразметка html
	Проверка разметки гугл
		https://search.google.com/structured-data/testing-tool/u/0/

	Онлайн уставновка разметки гугл
		https://www.google.com/webmasters/markup-helper/u/0/

-sass миксины (куски повторяющегося кода)
	bottom: $one * $two; //арифметические операции

	@mixin large-text {
		font: 300 1rem/1.2rem $font-main;
		color: red;
	} //создание миксина
	p {
		@include large-text;
		position: relative;
	}// вызов миксина

	@mixin my-border:($color, $width) {
		border{
			color: $color;
			width: $width;
			style: dashed;
		}
	} //создание миксина как функцию для занесения параметров в качестве его аргументов
	p {
		@include my-border:(red, 2px);
	} //вывод миксина
	h1 {
		@include my-border:(red);
	}//вывод миксина c 1 из 2х параметров

-Онлайн сервисы для макетов
	Zeplin PSD -> WEB 1 проект бесплатно
	Avocode PSD Sketch
	Figma Sketch
	Mockupplus прототипы -> HTML, exe, PNG

-Медиа стараться писать в своих стилях без отдельного include media
	.footer {
	  display: block;
	  width: 100%;
	  padding: 1rem 15px;
	  background: $bg-dark-color;//здесь идут стили для мобилы
	  @media screen and (min-width: 534px) {//здесь идут стили для десктопа
	    display: flex;
	    justify-content: space-between;
	  }
  }

-coverage для проверки используемого и неиспользуемого CSS В ХРОМЕ

-Pixel Perfect
	Заголовок на винде 600,а на Mac выглядит как 900 - сглаживание шрифтов (ответ он должен выглядеть так, как должен выглядеть на Виндовс и должен выглядеть так как должен выглядеть на Маке - не пытайтесь привести все к одному виду)

	-webkit - хром, мобильные и десктопные браузеры сафари(новый вебкит), Андроид (до версии киткат старый вебкит)
	-gecko -мозила (десктоп платформы мозилы +  и мозила андроид)

	На Iphone все браузеры используют встроенный движок вебкит
	На Android все браузеры идут в большинстве со своими движками или использую встроенный хромиум

	Размеры отступов шрифта, высоту строки, цвета еще можно гарантировать, то сглаживание текста, размытие теней, рендеринг графики и внешний вид системных контролов лучше даже не пытаться привести к общему виду.

-Видео с youtube
	https://www.youtube.com/watch?v=4JS70KB9GS0
	https://www.youtube.com/watch?v=4JS70KB9GS0

-Использование переменных в CSS
	Объявлять в root в начале документа
		:root {
		  --main-bg-color: brown;
		}
	Объвление переменной:
		element {
		  --main-bg-color: brown;
		}
	Использование переменной:
		element {
			background-color: var(--main-bg-color);
		}

-GET

	В конце адреса картинки или другого файла можно поставить ?img и тогда открыть консоль или нетворк и посмотреть инфу о файле

-пути
	Путь для относительных ссылок имеет три специальных обозначения:
	/ указывает на корневую директорию и говорит о том, что нужно начать путь от корневого каталога документов и идти вниз до следующей папки
	./ указывает на текущую папку
	../ подняться на одну папку (директорию) выше

-теговая карта

	https://html5book.ru/examples/html-tags.html

-заглушка под ie меньше 10

	https://github.com/burocratik/outdated-browser

-прокрутка вверх до якоря
	if($('.form-sidebar__link').length > 0 && $('#header').length > 0){
		$('body').on('click', '.form-sidebar__link', function (e) {
			e.preventDefault();
			var thisId = $(this).attr('href');
			$('html, body').animate({
				scrollTop: $(thisId).offset().top - $('#header').outerHeight()
			}, 1000);
		});
	}
	http://localhost:3000/add-excursion.html#section-basic-information
	<a class="form-sidebar__link" href="#section-basic-information">Основная информация</a>
	.form-sidebar {
	    position: sticky;
	    top: 0;
	    display: block;
	    padding: 5.688rem 0 1.875rem;
	    margin-top: -3.813rem;
	}

-верстка карточек товара
	https://html5book.ru/dizayn-kartochek-tovara/
	https://placeholder.com
	https://via.placeholder.com/728x90.png

-верстка под ie < 10

	Короче была такая программа которая спустя пару лет после моего рождения еще могла называться браузером

-Эмуляции

 В IE есть возможность эмуляции старых браузеров

-https://ru.bem.info БЭМ

	+emmet
		https://webcache.googleusercontent.com/search?q=cache:52WeDZKVNaAJ:https://docs.emmet.io/filters/bem/+&cd=1&hl=ru&ct=clnk&gl=ru

	имена блоков и элементов - кэмелкейсом
	блок всегда может существовать отдельно друг от друга в любом другом месте

	productItem__price - цена товара
	productItem__price productItem__price-sale - цена товара со скидкой (другой цвет цены) и там прописываются не все стили а только отличительные

	БЭМ Реакт https://www.youtube.com/watch?v=BuKeVrQmVKI

-Скринреадер NVDA

-кроссбраузерная верстка https://youtu.be/xFZWHLjNXdI?t=324

-кроссплатформенная верстка
	Соответственно видно, что добиться более-менее одинакового отображения шрифтов можно используя семейство sans-serif с указанием размера в пикселях. Я еще для более удобного чтения разряжаю текст, увеличивая межстрочный интервал: font: 12px/150% Verdana, sans-serif;

	Чтобы избежать ситуации, показанной на скриншоте выше, необходимо для каждого поля прописать свойство width с явным указанием размера в пикселях. Дефолтный размер форм или размер, указанный не в пикселях, может отличаться в разных браузерах под разными осями, причем иногда на много, из-за чего верстка может расползтись.

-использование фильтров css
	.blur {
	    filter: blur(5px);
	    -webkit-filter: blur(5px);
	    -moz-filter: blur(5px);
	    -o-filter: blur(5px);
	    -ms-filter: blur(5px);
	}
	https://html5book.ru/css3-filtry/

-Понимать отличие фиксированной, адаптивной и резиновой верстки
	фиксированная Блоки не меняют свою ширину. На мониторах с маленьким разрешением появляется горизонтальная полоса прокрутки.

	//разницу между дизайном mobile first и адаптивным мобильным дизайном(медиа-запросов), так как последний берет имеющиеся элементы и масштабирует их под экран, но не уменьшает при этом размер файла.

	отзывчвая(responsive, резиновый, медиа запросы) является частью адаптивного Блоки меняют свою ширину в зависимости от размера окна браузера

	адаптивный дизайн это резиновый макет + прогрессивное улучшение
	Воплощается с помощью @ Media или благодаря скриптам

-ПОТОК

	Когда размер экрана уменьшается, содержимое страницы начинает занимать больше высоты, и элементы начинают смещаться вниз. Такое поведение называется потоком

-Понимать особенности верстки под высокий ppi и mobile first проектов
	-mobile first: верстаем css стили и прям внутри блока указываем сверху вниз медиа запросы от 575 вниз до 1199

	-PPi + rem + @2 + @3 (ipad)
		em — в типографике относительная единица длины, равная размеру текущего шрифта

		Rem — это корневой em (Root Em). Он создан, чтобы облегчить вычислительные проблемы, с которыми многие иногда сталкиваются.
		Это единица типографики, равная корневому (базовому) значению font-size. Это значит, что 1rem всегда будет равен значению font-size, которое было определено в html.

-Уметь пользоваться cli интерфейсом //консоль

-Знать и применять таскранеры(постпроцессор), модуль-бандлеры //gulp, webpack

-Плагины
	gulp-email-design — бесценный инструмент при верстки писем,
	gulp-uncss — лучшее решение для оптимизации CSS файлов
	jqueryplaceholder
		if (!Modernizr.input.placeholder){
			$('input, textarea').placeholder();
		} //Если модернизер не поддерживает плейсхолдер то уключить его поддержку
	normilize css
		https://necolas.github.io/normalize.css/8.0.1/normalize.css

-закрытие robots.txt
	User-agent: *
	Disallow: /

-Анимации
	список анимируемых свойств https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_animated_properties
	статья анимации https://html5book.ru/css3-animation/#keyframes
	https://www.youtube.com/watch?v=YWjuEzhPYqs
	Если необходимо чтобы анимация выполнялась при загрузке страницы или нужна более сложная, чем от А состояния к B состоянию, то в таком случае более подходящим является CSS анимация.

	@keyframes shadow {
		from {text-shadow: 0 0 3px black;}
		50% {text-shadow: 0 0 30px black;}
		to {text-shadow: 0 0 3px black;}
	}//свойства которые будут анимироваться
	После объявления правила @keyframes, мы можем ссылаться на него в свойстве animation:
	h1 {
		font-size: 3.5em;
		color: darkmagenta;
		animation: shadow  2s infinite ease-in-out 1s infinite alternate; //имя, время проигрывания, вид анимации кубик бейзер от from до to, время задержки, цикличность(можно написать 4 цикла), задомнаперед
	}// по hover, чтобы остановить анимацию можно написать animation-play-state: paused

	-transition,
		CSS3-переходы позволяют анимировать исходное значение CSS-свойства на новое значение с течением времени, управляя скоростью смены значений свойств. Большинство свойств меняют свои значения за 16 миллисекунд, поэтому рекомендуемое время стандартного перехода — 200ms.
		https://html5book.ru/css3-transition/
		Если ты хочешь изменить элемент плавно с одного состояния в другой, лучше использовать transition

	-transform
		https://html5book.ru/css3-transform/
		CSS3-трансформации позволяют сдвигать, поворачивать и масштабировать элементы. Трансформации преобразовывают элемент, не затрагивая остальные элементы веб-страницы, т.е. другие элементы не сдвигаются относительно него.

-Корректная работа при вбивании реального текста, надёжность вёрстки
	Обязательно нужно проверять удаление заголовков! Бывает что отступы между блоками после этого схлопываются, это частая ошибка, причина — что отступы были заданы не для блоков, а для внутренних элементов — заголовоков.

	Проверяется: на странице с контентом, пробуем добавлять и удалять содержимое – «что будет когда текста много?», «а когда мало?».

	Проверяется: на страницы с контентом вбиваем текст с абзацами и без абзацев (важно! бывает горе-верстальщики прописывают стили только для абзацев), со списками и картинками, таблицами и заголовками разных уровней.

	margin-bottom от элемента должен быть равен margin-top по верстке за ним идущего

-Поддержка Retina
	gulp img retina
		npm install gulp-img-retina
		https://www.npmjs.com/package/gulp-img-retina

	Retina.js
		Steps:
			LESS
				Add the .at2x() mixin from retina.less to your LESS stylesheet
				In your stylesheet, call the .at2x() mixin anywhere instead of using background-image

				#logo {
				  .at2x('/images/my_image.png', 200px, 100px);
				}
			HTML
				For example, if you have an image on your page that looks like this:
					<img src="/images/my_image.png" />

					The script will check your server to see if an alternative image exists at this path:
					"/images/my_image@2x.png"

-Доступность при выключенных(загружающихся) картинках
	npm install posthtml-alt-always --save-dev
	npm install posthtml --save-dev

	npm install gulp-posthtml --save-dev

	gulpfile.js
		var posthtml = require('gulp-posthtml');

		gulp.task('html', function () {
		    return gulp.src('./src/*.html').pipe(
		        posthtml([
		            require('posthtml-alt-always')({ /* options */ })
		        ])
		    ).pipe(
		        gulp.dest('.')
		    );
		});

-Шрифты

	font-display - работает с прыжками шрифтов во время загрузки

	Подключать первым Woff2 потом woff, остальные нужны для браузеров которых нет в статисттике посещений моего сайта )

	Локальное подключение
		@font-face {
		  font-family: 'Open Sans';
		  font-weight: normal;
		  font-style: normal;
		  src: url(/fonts/OpenSans-Regular.eot); /* IE9 Compat Modes */
		  src: local('Open Sans Regular'), local('OpenSans-Regular'),
		    url(/fonts/OpenSans-Regular.eot) format('embedded-opentype'),
		    url(/fonts/OpenSans-Regular.woff) format('woff'),
		    url(/fonts/OpenSans-Regular.ttf) format('truetype'),
		    url(/fonts/OpenSans-Regular.svg#OpenSans-Regular) format('svg');
		}

	В этом примере используется локальный пользовательский шрифт "Helvetica Neue Bold"; если у пользователя этот шрифт не установлен (используются два различных имени), тогда вместо него используется загружаемый шрифт с названием "MgOpenModernaBold.ttf":
		@font-face {
		  font-family: MyHelvetica;
		  src: local("Helvetica Neue Bold"),
		       local("HelveticaNeue-Bold"),
		       url(MgOpenModernaBold.ttf);
		  font-weight: bold;
		}

	Замена шрифтов на аналогичный в Linux
		body {
			font-family: Arial, "Helvetica CY", "Nimbus Sans L", sans-serif;
			}

-Modernizer
	npm install --save-dev gulp-modernizr

	var modernizr = require('gulp-modernizr');

	gulp.task('modernizr', function() {
	  return gulp.src('./js/*.js')
	    .pipe(modernizr())
	    .pipe(gulp.dest('build/'))
	});

	Примеры
		.page:after {
			linear-gradient
		}

		Вместо этого
		.no-cssgradients .page {
			background: #123456 url('../img/img.png');
		}

-тестирование верстки
	Экстремальные состояния
		Экстремальными состояниями мы называем те, в которых чаще всего ломается вёрстка: длинные тексты (которые могут ещё и не содержать пробелов), отсутствие элементов в блоке и другие.

		https://developers.google.com/speed/pagespeed/insights/?hl=ru

		https://gtmetrix.com

-Типографика
	«Если вы хотите, чтобы вашему читателю было комфортно, каждая строка должна содержать не более 60 знаков.
	Длина строки не должна превышать 600 px
	Что касается мобильных устройств, придерживайтесь диапазона в 30-40 знаков в строке.

	По правилам, для обеспечения читабельности текста интерлиньяж должен быть примерно на 30% больше

	Кернинг — расстояние между буквами

	Кегль - высота в пунктах

	Выравнивание ВСЕГДА должно быть по левому краю

	Гарнитура
		normal, bold, italic (должно быть разная насыщенность в пределах одной гарнитуры)

	Насыщенность
		thin 100, 200 Extra Light (Ultra Light),  light 300, regular 400, medium 500, 600 Semi Bold, bold 700, 800 Extra Bold (Ultra Bold),  black 900

	Контрстность
		Проверить у нахаева

-Семантика
	Заголовки должны выделяться тегами H1, H2, H3, H4, но никак не B и STRONG.
	При создании меню лучше всего использовать UL список, внутри которого будут лежать LI элементы меню. Этим мы показываем, что ссылки равносильные. Если имеются пункты второй вложенности, соответственно создаем внутри первичного LI элемента еще один UL список.
	Все служебные картинки (иконки, стрелки, пульки…) должны быть прописаны в CSS коде. В HTML, тег IMG должен использоваться только для больших картинок. Большие, понятие растяжимое, скажем так, начиная с превьюшек 100 x 100 и выше.


	https://html5book.ru/css-background/
	<label class="file-default file-default_photo">
		<input class="file-default__input" type="file" name="photo[]">
		<div class="file-default__display">Загрузить фотографии с&nbsp;компьютера</div>
	</label>
	.main-form__uploaded-file-name_photo {
	    background: url(../img/theme/icons/photo-camera_default.svg) no-repeat center left;  //без повтора по центру по вертикали  слева по горизонтали
	    background-size: 1rem; //размер svg
	    //  div {background-size: 300px 150px;}
			div {background-size: 50% 30%;}
			div {background-size: cover;}
			div {background-size: contain;}
	}


	Параграф блока текста создается с помощью P тега, но никак не DIV.
	http://sitear.ru/material/semanticheskaya-verstka-semanticheskogo-koda

	<header> - несколько,
	<nav> - несколько,
	<article> - несколько (<article><h2>...</h2><p>...</p></article>),
	<article> внутри <section> - да (  section <- нет <- контент автономен -> да -> article )
	<section> — более крупный логический контейнер, объединяющий содержание по смыслу. Например, блок «О компании», список товаров, раздел личной информации в профиле и так далее.
	<article> — самостоятельный, цельный и независимый раздел документа. Этот раздел можно в неизменном виде использовать в различных местах, в том числе и на других сайтах. Примеры: статья, пост в блоге, сообщение на форуме и так далее.
	<address>
	<time> <time datetime="2014-09-25"> 25 Сентября 2014</time>
	<figure><img src="picture.jpg" alt="Осень"><figcaption>Осенний лес</figcaption></figure> - обертка с заголовком
	<figcaption> - чтение экранного диктора
	<mark> - выделение

-Теги + Стили

	-css правила
		Каждый селектор – на отдельной строке
			#snapshot-box h2,
			#profile-box h2,
			#order-box h2 {
			  padding: 0 0 6px 0;
			  font-weight: bold;
			}

		Свойства, сильнее влияющие на документ, идут первыми
			-Сначала положение элемента относительно других: position, left/right/top/bottom, float, clear, z-index.
			-Затем размеры и отступы: width, height, margin, padding…
			-Рамка border, она частично относится к размерам.
			-Общее оформление содержимого: list-style-type, overflow…
			-Цветовое и стилевое оформление: background, color, font…

	-outline не убирать для взаимодействия с элементом в фокусе (передвигаемся табом) с клавиатуры (кнопки, инпуты). Это все равно что писать в редакторе кода отвлечься, а потом ты не видишь где остановился и курсора тоже нет.

	-замена display: none; - так соседние элементы про него ничего не знают, он полностью вырубается из дерева и скринридеры его не видят
		добавлять класс
		.visually-hidden {
			position: absolute;
			clip: rect(0 0 0 0);
			width: 1px;
			height: 1px;
			margin: -1px;
		}

	-таблицы
		https://html5book.ru/shpargalka-po-tablicam/
		https://html5book.ru/krasivoe-oformlenie-tablic/

		vertical-align: top

	-правила использования кнопки, ссылки, div
		Если клик приведёт к смене адреса,
		этот адрес можно скопировать,
		отправить по электронной почте,
		на него можно снова зайти,
		это не адрес самой страницы - это ссылка
		hover, focus(TAB), active(кликнул ссылку но не отпустил), visited

	-Если клик не меняет адрес страницы,
		адрес нельзя скопировать
		и нельзя этим адресом поделиться — это кнопка.
		button, button:hover, button:focus, button:active

	-правила использвования dip p span
		div используется для группировки span элементов
		p используется для абзацев и группировки span элементов
		span используется для обертки 1 слова

	-Заголовки h1-h6
		h1 2rem (lh 3.34)
		h2 1.5rem (lh 3.16)
		h3 1.17rem (lh 3.17)
		h4 1rem (lh 1.33)
		h5 0.83rem (lh 1.67)
		h6 0.67rem (lh 2.33)

	-списки
		list-style: inside none;

	-font
		font: 400 .813rem/1.063rem $font-main;
		font: 300 italic 1.25rem/1.5rem $font-main;

		font: inherit;

		p strong {
	      font-weight: 700;
	    }

	-select
		+e('select').select_main-page(name='age', data-placeholder='от 12 до 17 лет')
            +e('option')
            +e('option')(value='0') Младше 12 лет

	-Ширина
	    width: auto;
	    max-width: 15rem;

	    width: max-content;

	-Текст
	    white-space: nowrap; //запрет переноса строки
	    text-overflow: ellipsis; //троеточие работает только с overflow: hidden;
	    hyphens: auto;//перенос текста

	-Списки
		.main-form__uploaded-file:last-child {
		    margin-bottom: 0;
		}

	-Изображения
		Карты
			https://html5book.ru/images-in-html/
			https://www.image-maps.com

	-формы
		<form name="mail-form" action="mailto:адрес вашей электронной почты" enctype="text/plain"></form>

		 <fieldset name="" disabled>
		    <legend>Контактная информация</legend>
		    <p><label for="name">Имя <em>*</em></label><input type="text" id="name"></p>
		    <p><label for="email">E-mail</label><input type="email" id="email"></p>
		 </fieldset>

		 +e('button').submit.button_default(type='submit', value='Подобрать')

		 INPUT
		 input type="image" Поле с изображением. При нажатии на рисунок данные формы отправляются на сервер.

		 <input type="button" /> не будут отправлять форму - они ничего не делают по умолчанию. Они обычно используются в сочетании с JavaScript как часть приложения AJAX.

		 autofocus

		 checked

		 type

		 placeholder

		 name

		 value Определяет текст, отображаемый на кнопке, в поле или связанный текст. Не указывается для полей типа file.

	-картинки

		приоритетом вставлять через css

		https://shwr.me

		https://html5book.ru/css-background/

		<label class="file-default file-default_photo">
			<input class="file-default__input" type="file" name="photo[]">
			<div class="file-default__display">Загрузить фотографии с&nbsp;компьютера</div>
		</label>
		.main-form__uploaded-file-name_photo {
		    background: url(../img/theme/icons/photo-camera_default.svg) no-repeat center left;  //без повтора по центру по вертикали слева по горизонтали
		    background-size: 1rem; //размер svg
		    //  div {background-size: 300px 150px;}
				div {background-size: 50% 30%;}
				div {background-size: cover;}
				div {background-size: contain;}
		} //для иконок которые не требуется менять в CMS

		&_fb {
	        background-image: url(../img/theme/socials/fb.svg);
      	} Иконка фейсбкука

		& .slick-prev:before {
		    position: absolute;
		    content: '\f053';
		    display: block;
		    font-family: $icons-font;
		    top: 10px;
		    left: 45px;
		    @include responsive-font-size(35px);
		    cursor: pointer;
		    color: red;
		  } //fontawesome

	  	.album-gallery .image-wrap {
		    object-fit: cover;
		    object-position: center;
		    height: 100%;
		    max-height: 82px;
		}  //картинка
		.album-gallery .image-wrap {
		    height: 171px;
		    flex: 0 0 33.33333%;
		    max-width: 33.33333%;
		    position: relative;
		    width: 100%;
		    min-height: 1px;
		}//родитель  - просто пример


		figure
		    flex: 0 0 30%;
		    position: relative
	    a
		    position: absolute;
		    left: 0;
		    top: 0;
		    width: 100%;
		    height: auto;
		    display: block;
	    img
	    	width: 100%;
	    	height: 100%;
		div
			//pr30px отступ влево если карточка горизоньальная
			http://union.acommandpro.com - карточка товара через тег img


		<figure class="public__img-block">
	        <div class="public__img" style="background-image: url(img/content/public/bread.png)"></div>
	    </figure>
	    figure {
		    position: relative;
		    display: block;
		    height: 12.5rem;
	    }
	    .public__img {
		    border-top-left-radius: 2rem;
		    border-top-right-radius: 2rem;
		    position: absolute;
		    top: 0;
		    left: 0;
		    right: 0;
		    bottom: 0;
		    //height: 100%
		    background-repeat: no-repeat;
		    background-position: center top;
		    background-size: cover;
		} -приоритет верстать так
		https://basik.ru/images/1920x1080_63/16_1920x1080.jpg
		http://top-desktop.ru/files/priroda/1024/97.jpg


		-еще как вариант без абсолютного позиционирования  - крайний случай для долбоебов бэкэндов
			<div class="main-page-popular-program__img-container">
                <img class="main-page-popular-program__img" src="http://top-desktop.ru/files/priroda/1024/97.jpg" alt="Edinburgh SRUC Oatridge Campus">
            </div>
            .main-page-popular-program__img-container {
			    position: relative;
			    margin-bottom: 1.125rem;
			    max-height: 152px;
			    overflow: hidden;
			}

	-absolute
		transform: translateX(-50%);
		transform: translate(50%, 50%);

	-text-align:center
		выравнивает контент внутри блока по центру
	-margin 0 auto выравнивает блок с контентов по центру

	-масонри сетка
		https://zaurmag.ru/javascript-jquery/masonry-kirpichnyj-effekt-elementov-na-sajte-dokumentatsiya-na-russkom-yazyke.html

	-bootstrap

		Контейнер открывать внутри section или header footer
		row использовать только когда нужно что то перераскидать на медиа, или карточек товаров

		bs3 x<767 - xs; 768<x<991 sm; 991<x<1199 - md; x>1200 - lg;
		bs4 x<576 - col; 576<=x<=767 sm; 768<=x<=991 - md; 992<=x<=1199 - lg; x>=1200 -xl;

		.col-lg-4.col-sm-6.order-lg-1.order-sm-2.order-3 //порядок
		.order-lg-last

		.container {
		    width: 100%;
		    padding-right: 15px;
		    padding-left: 15px;
		    margin-right: auto;
		    margin-left: auto;
		    max-width: 1200px;
		}
		.row {
		    display: flex;
		    flex-wrap: wrap;
		    margin-right: -15px;
		    margin-left: -15px;
		}
		.col-6 {
		    -ms-flex: 0 0 50%;
		    flex: 0 0 50%;
		    max-width: 50%;
	        position: relative;
		    width: 100%;
		    min-height: 1px;
		    padding-right: 15px;
		    padding-left: 15px;
		}

		<div class="col-lg-2 order-lg-last"> делает эту колонку последней внутри row в дом дереве
		<div class="col-lg-10">

	-flex
		flex: none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]
		https://www.youtube.com/watch?v=38bMnJ2l4bg
		https://www.youtube.com/watch?v=hrFPD0nkRVA

		align-self – выравнивание отдельно взятого flex-блока по поперечной оси (виртикали),хотя у остальных блоков о родителя могут быть заданы другие свойства

		Ширина flex-basis равна и заменяет свойство width
			flex-basis:20%; аналогично width: 20% можно использовать без наличия у самого элемента свойства display flex и обязательно наличие df у родитетя!!! при этом задать карточке внешний margin а родителю повесить jcsa

		порядок
			.flex-item {
				-webkit-order: 1;
				order: 1; //прописать всем блокам от родителя
			}

		Жадность
			Жадность начинает работать если не равна 0 и если оставшееся место в строке позволяет растнуться жадному элементу, то он растягиватся. Жадность работает когда она физически выше чем значение flex basis в конкретном случае

			flex-grow: 2; //будет больше чем остальные блоки а остальным прописать 1
			по умолчанию все карточки товара имеют flex-grow: 0 и если одной из карточек дать flex-grow: 1 то она займет все пространство свободное и оттеснит к правому краю остальные карточки
			пространство делится на 6 и 1 1 3 1 = 1\6 1\6 3\6 1\6 обязательно указать flex basis в пикселях или процентах и тогда норм будет ) https://youtu.be/hrFPD0nkRVA?t=3900
			чтобы соскочивший элемент не был на всю ширину нужно поставить flex-grow: 0; и родителю jcc
			попробовать для карточки вместо flex-basis - min width

		stretch когда один из блоков по горизонтали имеет больше контента чем его соседи то позволяет вытянуть соседей по высоте по нему

	-Селекторы
		https://code.tutsplus.com/ru/tutorials/the-30-css-selectors-you-must-memorize--net-16048
		Контекстные
			li a {
				text-decoration: none;
			}

		Псевдо
			a:link { color: red; }
			a:visted { color: purple; }

		Соседний элемент следующий сразу за указанным элементом
			ul + p {
			 	color: red;
			}

		Прямой потомок
			div#container > ul {
				border: 1px solid black;
			}

		ul ~ p {
			 color: red;
		}
		Этот селектор похож на X + Y, но он менее строгий. Соседний селектор (ul + p) выберет только первый элемент, следующий сразу же за указанным элементом. Селектор X ~ Y выберет все элементы p, расположенные после элемента ul.

		Это селектор атрибутов. Он выберет только те ссылки, у которых имеется указанный атрибут title
		a[title] {
		 	color: green;
		}

		Отмеченный чекбокс
		.checkbox-default__input:checked ~ .checkbox-default__display:before {
		    background: #ff440e;
		    border-color: #ff440e;
		}


		<label class="check option">
			<input class="check__input" type="checkbox" checked>
			<span class="check__box"></span>
			Второй
		</label>
		.check__box {
			position: absolute;
			margin-left: -1.2em;
			width: 1em;
			height: 1em;
			background-image: url(https://cdn.glitch.com/d6162378-5823-4160-a555-3d9789bd2b92%2Foff.svg?1550563355034);
		}
		.check__input {
			position: absolute;
			width: 1px;
			height: 1px;
			overflow: hidden;
			clip: rect(0 0 0 0);
		}
		.check {
			padding-left: 1.2em;
		}
		/* Checked */

		.check__input:checked + .check__box {
			background-image: url(https://cdn.glitch.com/d6162378-5823-4160-a555-3d9789bd2b92%2Fon.svg?1550563355439);
		}
		/* Focused */
		.check__input:focus + .check__box {
			background-image: url(https://cdn.glitch.com/d6162378-5823-4160-a555-3d9789bd2b92%2Foff-focused.svg?1550563355021);
		}
		.check__input:checked:focus + .check__box {
			background-image: url(https://cdn.glitch.com/d6162378-5823-4160-a555-3d9789bd2b92%2Fon-focused.svg?1550563355063);
		}
		/* Disabled */
		.check__input:disabled + .check__box {
			background-image: url(https://cdn.glitch.com/d6162378-5823-4160-a555-3d9789bd2b92%2Foff-disabled.svg?1550563354916);
		}
		.check__input:checked:disabled + .check__box {
			background-image: url(https://cdn.glitch.com/d6162378-5823-4160-a555-3d9789bd2b92%2Fon-disabled.svg?1550563354883);
		}


		Псевдокласс отрицания бывает очень полезен. Представьте, что вам нужно выбрать все тэги div, кроме одного с id равным container
		div:not(#container) {
			 color: blue;
		}

		Выберем первую букву параграфа
			p::first-letter {
			 float: left;
			 font-size: 2em;
			 font-weight: bold;
			 font-family: cursive;
			 padding-right: 2px;
		}